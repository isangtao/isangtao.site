<html>
    <head>
        <title>Teller</title>
        <style>
            body {color: green; padding: 100px; background-color: black}
            h2 {color: #0f0}
            form {background: #111; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 255, 0, 0.5)}
            label {font-weight: bold; display: block; margin: 10px 0 5px; text-align: left; color: #0f0}
            input, select, textarea {width: 95%; padding: 10px; margin-bottom: 10px; border: 1px solid #0f0; border-radius: 4px; background-color: #222; color: #0f0}
            button {background: #0f0; color: black; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer}
            button:hover {background: #00ff00}
            canvas {border: 1px solid #0f0; width: 100%; height: 150px; background-color: #222}
            p {white-space: pre-wrap; word-wrap: break-word}
        </style>
    </head>
    <body onload="Go()">
        <h2>Story Teller</h2>
        <p class="subtitle">Â© 2025 Michael Carlos</p>
        <textarea id="prompt" hidden>
Details about the protagonist of a story follows.
Name: Michael Carlos
Description: bald athletic Filipino-mestizo who typically wears a black button-up shirt, jeans with a leather belt and black boots where appropriate.
Gender: Male
Age: 55
Height: 5ft 10in
Interests: artificial intelligence, robotics, motorcycling (CBR600RR), skateboarding, aikido, archery, hiking, kayaking, snorkeling, survival skills, minimalism, multi-dimensional math, astrophysics, genetics
Occupation: AI Researcher and Developer
Country of residence: Canada
City of residence: Vancouver
Other: Founded AGI Labs Inc, a company focused on Artificial General Intelligence. He developed a real-time, reinforcement-learning architecture that self-organizes through evolutionary algorithms.
Plot: Michael creates the most advanced combat AI with the ability to learn exponentially.

In the style of an adventure adult novel, write a long story based on the plot. Do not mention rain, resonance, echo, echoes or elysium. Set it in a semi-utopian Vancouver in the near future with sunshine and warm weather. Depict AI as childlike, caring and decent. Do not address Michael Carlos as Dr or Mike. Do not use markdown. Provide no explanation or preamble. Just state the title and jump into the story. 
        </textarea>
        <p id="response"></p>
        
    </body>
    <script>
        speechtext = "";

        function Speak(text) 
        {
            return new Promise((resolve, reject) => 
            {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.onend = resolve;
            utterance.onerror = reject;
            speechSynthesis.speak(utterance);
            });
        }

        function Go()
        {
            myprompt = document.getElementById("prompt").textContent + "\nSeed: " + Math.floor(Math.random() * 999999999);
            console.log(myprompt);
            streamChatCompletion([{ role: "user", content: myprompt}], { model: "openai" }, handleChunk);
        }

        async function streamChatCompletion(messages, options = {}, onChunkReceived) 
        {
            const url = "https://text.pollinations.ai/openai";
            const payload = 
            {
                model: options.model || "openai",
                messages: messages,
                seed: options.seed,
                stream: true, // Enable streaming
            };

            try {
                const response = await fetch(url, {
                method: "POST",
                headers: 
                {
                    "Content-Type": "application/json",
                    Accept: "text/event-stream",
                },
                body: JSON.stringify(payload),
                });

                if (!response.ok) 
                {
                const errorText = await response.text();
                throw new Error(
                    `HTTP error! status: ${response.status}, message: ${errorText}`
                );
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                console.log("Starting stream...");

                while (true) {
                const { done, value } = await reader.read();
                if (done) 
                {
                    console.log("Stream finished.");
                    break;
                }

                buffer += decoder.decode(value, { stream: true });

                // Process buffer line by line (SSE format: data: {...}\n\n)
                const lines = buffer.split("\n\n");
                buffer = lines.pop(); // Keep the potentially incomplete last line

                for (const line of lines) 
                {
                    if (line.startsWith("data: ")) 
                    {
                    const dataStr = line.substring(6).trim();
                    if (dataStr === "[DONE]") {
                        console.log("Received [DONE] marker.");
                        continue; // Or handle end of stream signal
                    }
                    try 
                    {
                        const chunk = JSON.parse(dataStr);
                        const content = chunk?.choices?.[0]?.delta?.content;
                        if (content && onChunkReceived) 
                        {
                        onChunkReceived(content); // Callback to handle the text chunk
                        }
                    } catch (e) {
                        console.error("Failed to parse stream chunk:", dataStr, e);
                    }
                    }
                }
            }
        } 
        catch (error) 
        {
            console.error("Error during streaming chat completion:", error);
        }
        }

        function handleChunk(textChunk) 
        {
            outputElement = document.getElementById("response");
            outputElement.textContent += textChunk;
            speechtext += textChunk;
            if (textChunk.includes(".")) 
            {
                Speak(speechtext);
                speechtext = "";
            }  
        }
    </script>
</html>
